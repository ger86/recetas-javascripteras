# ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ 4 ways to clone objects in Javascript

```js
const noahsArk = { cat: "ğŸ±", dino: "ğŸ¦•", lion: "ğŸ¦", dog: "ğŸ¶" };
```

## 1ï¸âƒ£ Spread operator

```js
const clonedNoahsArk = { ...noahsArk };
```

## 2ï¸âƒ£ Object assign

```js
const anotherNoashArk = Object.assign({}, noahsArk);
```

## â—ï¸ Be careful with shallow cloning

```js
const noahsArk = {
  animals: ["ğŸ±", "ğŸ¦•"],
  people: ["ğŸ‘¦", "ğŸ‘©"],
};

const clonedNoahsArk = { ...noahsArk };
noahsArk.people.push("ğŸ‘¶");

console.log(noahsArk); // { animals:  ["ğŸ±", "ğŸ¦•"], people: ["ğŸ‘¦", "ğŸ‘©", "ğŸ‘¶"] }
console.log(clonedNoahsArk); // { animals:  ["ğŸ±", "ğŸ¦•"], people: ["ğŸ‘¦", "ğŸ‘©", "ğŸ‘¶"] }
```

## 3ï¸âƒ£ JSON

```js
const justAnotherArk = JSON.parse(JSON.stringify(noahsArk));
```

## 4ï¸âƒ£ Structured clone

The global `structuredClone()` method creates a deep clone of a given value using the structured clone algorithm. It solves the problems with shallow cloning.

```js
const dinosaur = {
  name: "T-Rex",
  address: {
    town: "Jurassic Park",
    island: "Nublar island",
  },
};

const clonedDinosaur = structuredClone(dinosaur);

dinosaur === clonedDinosaur; // false;

clonedDinosaur.address.town = "Jurassic World";

console.log(dinosaur.address.town); // 'Jurassic Park'
console.log(clonedDinosaur.address.town); // 'Jurassic World'
```

Structured cloning can handle cyclical data structures, support many built-in data types and is generally more robust and often faster.

## âŒ Assignment is not cloning

```js
const failedClone = noahsArk;
noahsArk.dino = "ğŸ¦–";
console.log(noahsArk); // { cat: "ğŸ±", dino: "ğŸ¦–", lion: "ğŸ¦", dog: "ğŸ¶"}
console.log(failedClone); // {cat: "ğŸ±", dino: "ğŸ¦–", lion: "ğŸ¦", dog: "ğŸ¶"}
```

## â˜•ï¸ If you liked it, you can invite me for a coffee at:

https://www.buymeacoffee.com/latteandcode
